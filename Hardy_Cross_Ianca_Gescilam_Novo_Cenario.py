# -*- coding: utf-8 -*-
"""Cópia de Hardy_Cross_V4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sCF8xLEG2SjHYI1nAW81FwiwvXU3n6E5
"""

# -*- coding: utf-8 -*-
"""
Created on Tue Apr 19 09:30:46 2022

@author: Gescilam SOUSA e Ianca MIRANDA
"""

import numpy as np

def calculo_f (e, D, Q):
    ni = 1.002*10**-6
    # Calculo do Re em funcao da vazao - [Q] = l/s
    Re = 4*(np.absolute(Q)/1000)/(np.pi*D*ni)
    # Swamee Completo valido para os escoamentos laminar e turbulento
    f = ((64/Re)**8+9.5*(np.log((e/(3.7*D*1000))+(5.74/Re**0.9))-(2500/Re)**6)**-16)**0.125
    # Swamee Incompleto
    #f = 0.25/(np.log10(e/(3.7*D)+5.74/Re**0.9))**2
    return f

def hardy_cross_k (f, L, D): 

  #Derivado da equacao da Perda de Carga Universal
  return 8.0*f*L/(9.81*np.power(np.pi,2.0)*np.power(D,5.0))

def hardy_cross_numerator (k, Q): 
  # perda de carga
  return k*(Q/1000)*np.power(np.absolute(Q/1000),1.0)


def hardy_cross_denominator (k,Q):

  #return 2*k*Q/(k*Q)
  return 2*k*np.power(np.absolute(Q/1000),1.0)

def delta_Q_correcao (numerator, denominator) : #incremento nas vazoes

  return -1.0*numerator/denominator

def hardy_cross_loop_interacao (pipes_k, pipes_Q, pipes_name=None):

  numerator_sun = 0.0
  denominator_sun = 0.0

  for j in range (len(pipes_Q)): #funcao para gerar sequencia 
    numerator_sun += hardy_cross_numerator (pipes_k[j],pipes_Q[j])
    #print ("numerator_sun %f" %numerator_sun)
    denominator_sun += hardy_cross_denominator (pipes_k[j],pipes_Q[j])
    #print ("denominator_sun %f" %denominator_sun)
    
  delta_Q = delta_Q_correcao (numerator_sun, denominator_sun)
  #print ("delta Q %f" %delta_Q)
  
  return delta_Q

def main():
    #D = 50*10**-3
    e = 0.0015 #mm valor tabelado Livro Prof. Rodrigo Porto
    
    #Anel 1
    one_name_array = ('1-2','2-3','3-4','4-5','5-6','6-7','7-8','8-1') #trechos
    L_one_name_array = np.array([100.00,100.00,100.00,100.00,100.00,100.00,100.00,100.00])
    D_one_name_array = np.array([100.00,100.00,100.00,100.00,100.00,100.00,100.00,100.00])
    one_Q_guess_array = np.array([31.00,26.10,14.80,10.00,-7.40,-15.60,-23.10,-31.00]) #chutes inicias das vazões
    one_K_array = np.array([1,1,1,1,1,1,1,1]) #Somente para marcar o tamanho do array
    
    #Anel 2
    two_name_array = ('1-9','9-10','10-11','11-12','12-3', '3-2', '2-1')
    L_two_name_array = np.array([100.00,100.00,100.00,100.00,100.00,100.00,100.00])
    D_two_name_array = np.array([150.00,150.00,150.00,150.00,150.00,100.00,100.00])
    two_Q_guess_array = np.array([31.40,24.20,21.40,14.90,9.70,-26.10,-31.00])
    two_K_array = np.array([1,1,1,1,1,1,1,1])
    
    
    #Anel 3 
    three_name_array = ('3-13','13-14','14-15','15-16','16-17','17-5', '5-4', '4-3')
    L_three_name_array = np.array([100.00,100.00,100.00,100.00,100.00,100.00,100.00,100.00]) 
    D_three_name_array = np.array([150.00,150.00,150.00,150.00,150.00,150.00,100.00,100.00]) 
    three_Q_guess_array = np.array([14.80,8.00,1.30,-2.70,-6.40,-14.70,-10.00,-14.80]) 
    three_K_array = np.array([1,1,1,1,1,1,1,1])

    #Variaveis para o desvio maximo
    deltaTotal = 50
    desvioMaximo = 10**(-6)
    
        
    while deltaTotal > desvioMaximo:
    
        # uma interacao para o loop one
        for j in range(len(one_Q_guess_array)):
            Q1 = one_Q_guess_array[j]
            D1 = D_one_name_array[j]/1000
            #print ("Q1 %f" %Q1)
            f1 = calculo_f(e, D1, Q1)
            #print ("f1 %f" %f1)
            L1 = L_one_name_array[j]
            k1 = hardy_cross_k(f1, L1, D1)
            one_K_array[j] = k1
            
        delta_Q1 = hardy_cross_loop_interacao(one_K_array, one_Q_guess_array, one_name_array)
        #Primeiro chute e primeira correcao
        
        for j in range(len(one_Q_guess_array)):
            one_Q_guess_array[j] += delta_Q1
        
        # uma interacao para o loop two
        for j in range(len(two_Q_guess_array)):
            Q2 = two_Q_guess_array[j]
            D2 = D_two_name_array[j]/1000
            #print ("Q2 %f" %Q2)
            f2 = calculo_f(e, D2, Q2)
            #print ("f2 %f" %f1)
            L2 = L_two_name_array[j]
            k2 = hardy_cross_k(f2, L2, D2)
            two_K_array[j] = k2
        
        delta_Q2 = hardy_cross_loop_interacao(two_K_array, two_Q_guess_array, two_name_array)
        
        for j in range(len(two_Q_guess_array)):
            two_Q_guess_array[j] += delta_Q2
            #print ("A vazao da tubulacao: %s is %f" % (pipes_name[j], pipes_Q[j]))
        
        # uma interacao para o loop three
        
        for j in range(len(three_Q_guess_array)):
            Q3 = three_Q_guess_array[j]
            D3 = D_three_name_array[j]/1000
            #print ("Q3 %f" %Q3)
            f3 = calculo_f(e, D3, Q3)
            #print ("f3 %f" %f1)
            L3 = L_three_name_array[j] 
            k3 = hardy_cross_k(f3, L3, D3)
            #deltaH3= k3*(Q3/1000)**2
            #print ("deltaH3 %f" %deltaH3)
            # SomatoriodeltaH3 += deltaH3
            #print ("k1 %f" %k1)
            three_K_array[j] = k3
        
        delta_Q3 = hardy_cross_loop_interacao(three_K_array, three_Q_guess_array, three_name_array)

        for j in range(len(three_Q_guess_array)):
            three_Q_guess_array[j] += delta_Q3
        
        #Trechos compartilhados entre aneis - P/ manter a conservacao da massa
        one_Q_guess_array[0] -= delta_Q2
        one_Q_guess_array[1] -= delta_Q2
        one_Q_guess_array[2] -= delta_Q3
        one_Q_guess_array[3] -= delta_Q3
        two_Q_guess_array[5] -= delta_Q1
        two_Q_guess_array[6] -= delta_Q1
        three_Q_guess_array[6] -= delta_Q1
        three_Q_guess_array[7] -= delta_Q1
        
        deltaTotal = np.absolute(delta_Q1)+np.absolute(delta_Q2)+np.absolute(delta_Q3)

        
        
    print ("Os cálculos estão completos")
       
    print ("Loop one")
    for j in range(len(one_Q_guess_array)):
        print ("Tubulação - %s vazão: %f l/s" %(one_name_array[j],one_Q_guess_array[j]))
    
    print ("Loop two")
    for j in range(len(two_Q_guess_array)):
        print ("Tubulação - %s vazão: %f l/s" %(two_name_array[j],two_Q_guess_array[j]))
    
    print ("Loop three")
    for j in range(len(three_Q_guess_array)):
        print ("Tubulação - %s vazão: %f l/s" %(three_name_array[j],three_Q_guess_array[j]))
  
    #Calculo das pressoes:
    print ("Pressões nos nós sao:")
    #Loop01
    
    #calcular perda de carga para trecho R-1
    D_R_1 = 300/1000
    L_R_1 = 100
    Q_R_1 = 100.00
    cota_R = 245.00
    f_R_1 = calculo_f(e, D_R_1, Q_R_1) 
    k_R_1 = hardy_cross_k(f_R_1, L_R_1, D_R_1)
    perda_R_1 = k_R_1 * (Q_R_1/1000)**2
    #print ("perda_R_1 %f" %perda_R_1)
    

    #Calculo no sentido horario do loop 01
    one_name_pontos = ('1','2','3','4','5','6','7','8') 
    one_cota_mont = np.array([220.5,215.6,210.4,210.5,209.5,213.2,218.5,230.7])
    dif_cota = 245.00 - one_cota_mont[0]
    print ("Pressão no Nó %s é %f mca" %(one_name_pontos[0],dif_cota-perda_R_1))
    PressaoAcumulada = 0
    
    for j in range(len(one_cota_mont)-1):
      cota_jusante = one_cota_mont[j+1]
      dif_cota = cota_R - cota_jusante
      #print ("dif_cota %f" %dif_cota)
      if (j==0):
        perda_trecho = perda_R_1
       #PressaoAcumulada = dif_cota - perda_trecho
       #print ("Pressão no Nó %s é %f mca" %(one_name_pontos[j],PressaoAcumulada))
      perda_trecho += one_K_array[j] * (one_Q_guess_array[j]/1000)*np.power(np.absolute(one_Q_guess_array[j]/1000),1.0)
      PressaoAcumulada = dif_cota - perda_trecho
      print ("Pressão no Nó %s é %f mca" %(one_name_pontos[j+1],PressaoAcumulada))

    #Calculo no sentido horario do loop 02
    two_name_pontos = ('1','9','10','11','12')
    two_cotas_mont = np.array([220.5,211.5,213.5,205.5,208.8])

    PressaoAcumulada = 0
    perda_trecho = 0
    dif_cota = 0
    #Loop02
    #two_name_array = ('1-9','9-10','10-11','11-12','12-3', '3-2', '2-1')
    for j in range(len(two_cotas_mont)-1):
      cota_jusante = two_cotas_mont[j+1]
      dif_cota = cota_R - cota_jusante
      #print ("dif_cota %f" %dif_cota)
      if (j==0):
        perda_trecho = perda_R_1
      perda_trecho += two_K_array[j] * (two_Q_guess_array[j]/1000)*np.power(np.absolute(two_Q_guess_array[j]/1000),1.0)
      PressaoAcumulada = dif_cota - perda_trecho
      print ("Pressão no Nó %s é %f mca" %(two_name_pontos[j+1],PressaoAcumulada))

    #Calculo no sentido horario do loop 03
    three_name_pontos = ('3','13','14','15','16','17')
    three_cotas_mont = np.array([210.4,215.5,212.6,207.5,219.4,220.5])

   #calcular perda de carga para trecho R-3
    f_1_2 = calculo_f(e, 100/1000, one_Q_guess_array[0]) 
    k_1_2 = hardy_cross_k(f_1_2, 100, 100/1000)
    perda_1_2 = k_1_2 * (one_Q_guess_array[0]/1000)*np.power(np.absolute(one_Q_guess_array[0]/1000),1.0)
    #print ("perda_1_2 %f" %perda_1_2)
    f_2_3 = calculo_f(e, 100/1000, one_Q_guess_array[1]) 
    k_2_3 = hardy_cross_k(f_2_3, 100, 100/1000)
    perda_2_3 = k_2_3 * (one_Q_guess_array[1]/1000)*np.power(np.absolute(one_Q_guess_array[1]/1000),1.0)
    #print ("perda_2_3 %f" %perda_2_3)

    PressaoAcumulada = 0
    perda_trecho = 0
    dif_cota = 0
    #Loop03
    for j in range(len(three_cotas_mont)-1):
      cota_jusante = three_cotas_mont[j+1]
      dif_cota = cota_R - cota_jusante
      #print ("dif_cota %f" %dif_cota) 
      if (j==0):
        perda_trecho = perda_R_1 + perda_1_2 + perda_2_3
      perda_trecho += three_K_array[j] * (three_Q_guess_array[j]/1000)*np.power(np.absolute(three_Q_guess_array[j]/1000),1.0)
      PressaoAcumulada = dif_cota - perda_trecho
      print ("Pressão no Nó %s é %f mca" %(three_name_pontos[j+1],PressaoAcumulada))

    # Perdas de carga por anel
    print ("As perdas de carga nos loops sao sao:")
    Perda_anel01 = 0
    for j in range(len(one_Q_guess_array)):
      Q1 = one_Q_guess_array[j]
      D1 = D_one_name_array[j]/1000
      #print ("Q1 %f" %Q1)
      f1 = calculo_f(e, D1, Q1)
      #print ("f1 %f" %f1)
      L1 = L_one_name_array[j]
      k1 = hardy_cross_k(f1, L1, D1)
      Perda_anel01 += k1 * (one_Q_guess_array[j]/1000)*np.power(np.absolute(one_Q_guess_array[j]/1000),1.0)
    print ("A perda de carga no Loop 01 é %f" %Perda_anel01)
    
    Perda_anel02 = 0
    for j in range(len(two_Q_guess_array)):
      Q2 = two_Q_guess_array[j]
      D2 = D_two_name_array[j]/1000
      #print ("Q1 %f" %Q1)
      f2 = calculo_f(e, D2, Q2)
      #print ("f1 %f" %f1)
      L2 = L_two_name_array[j]
      k2 = hardy_cross_k(f2, L2, D2)
      Perda_anel02 += k2 * (two_Q_guess_array[j]/1000)*np.power(np.absolute(two_Q_guess_array[j]/1000),1.0)
    print ("A perda de carga no Loop 02 é %f" %Perda_anel02)
   
    Perda_anel03 = 0
    for j in range(len(three_Q_guess_array)):
      Q3 = three_Q_guess_array[j]
      D3 = D_three_name_array[j]/1000
      #print ("Q1 %f" %Q1)
      f3 = calculo_f(e, D3, Q3)
      #print ("f1 %f" %f1)
      L3 = L_three_name_array[j]
      k3 = hardy_cross_k(f3, L3, D3)
      Perda_anel03 += k3 * (three_Q_guess_array[j]/1000)*np.power(np.absolute(three_Q_guess_array[j]/1000),1.0)
    print ("A perda de carga no Loop 02 é %f" %Perda_anel03)

if __name__ == "__main__":
    main()





